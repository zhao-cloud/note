设计模式遵循的7大原则
1. 单一职责原则
  一个类只应该负责一个职责，如果A类负责两个不同的职责：职责1，职责2。当职责1需求变更而改变A时，可能造成职责2的执行错误，所以需要将A类的粒度分解为A1,A2
2.接口隔离原则
  A类通过接口interface依赖（使用）B类（B类实现了interface），但是并不是使用interface中所有的抽象方法，需要将interface拆开成使用的方法interface1 和 未使用的方法interface2 然后B类实现   interface1. 总之我们希望A类通过接口使用B类时，interface是最小的
3.依赖倒转原则
  高层模块不要依赖低层模块，二者都应该依赖其抽象。面向接口编程
  依赖关系传递的三种方法：1 接口传递  2 构造方法传递  3 setter方法传递
4.里氏替换原则
  如果对每个类型为T1的对象o1,都有类型为T2的对象o2,使得以T1定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。换句话说，所有引用基类的地方必须能够透明地使用其子类的对象。在继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法。
5.开闭原则（核心原则）
  一个软件实体如类，模块和函数应该对扩展开放（对提供方），对修改关闭（对使用方）。用抽象构建框架，用实现扩展细节。当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。
6.迪米特法则
  一个对象应该对其他对象保持最少的了解。类与类关系越密切，耦合度越大。迪米特法则又叫最少知道原则，即一个类对自己依赖的类知道的越少越好。也就时说对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的public方法，不对外泄露任何信息。迪米特法则还有个更简单的定义：只与直接的朋友通信 成员变量 方法参数 方法返回值 都是直接朋友 局部变量不是直接朋友
7.合成复用原则

核心思想
  找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混到一起。
  针对接口变成，而不是针对实现变成
  为了交互对象之间的松耦合设计而努力

UML--unified modeling language(统一建模语言)
Dependency  依赖：使用  只要类中用到了对方就存在依赖关系
Association 关联：如果一个类使用了另一个类 那么他们就是关联关系 关联关系是一种特殊的依赖关系 关联关系具有指向性，多重性
Generalization 泛化：继承  是依赖关系中的一种特殊情况
Realization 实现
Aggregation 聚合:A类里有一个成员变量B类，B类是通过set方法进行传递的就认为A类聚合了B类 A的产生B并不一定会产生，A消亡并不会引起B的消亡，即A与B可以分离
Composite   组合：A类里有一个成员变量B类，A的产生B一定会产生，A消亡会引起B的消亡 同生共死

设计模式
  单例模式：即采取一定的方法保证整个软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得对象实例的方法（这种方法一般都是静态方法）。
    1.饿汉式（静态常量）
      步骤：1）构造器私有化（防止使用new关键字创建对象）
           2）在类的内部创建对象
           3）向外暴露一个静态的公共方法用于返回该类的对象实例。getInstance
           public class A{
           private A(){}
           private final static A instance = new A();
           public static A getInstance(){
           return instance;
              }
           }
           缺点：类加载的时候就创建，没有懒加载，造成内存的浪费
     2.饿汉式（静态代码块）
          public class A{
           private A(){}
           static{//在静态代码块中，创建实例对象
              instance = new A();
           }
           private static A instance;
           public static A getInstance(){
           return instance;
              }
           }
           缺点：类加载的时候就创建，没有懒加载，造成内存的浪费
      3.懒汉式（线程不安全）
          public class A{
             private static A instance;
             private A(){}
             //提供一个静态公有方法，当使用到该方法时，才去创建instance
             //即懒汉式
             public static A getInstance(){
                if(instance == null){
                    instance = new A();
                }
                return instance;
                }
           }
           优点：可以实现懒加载方式
           缺点：线程不安全，实际开发中不能使用该方式，有潜在的风险
      4.懒汉式（线程安全，同步方法）
          public class A{
            private static A instance;
            private A(){}
            //加入同步代码，解决线程不安全问题
             public static sychronized A getInstance(){
                if(instance == null){
                    instance = new A();
                }
                return instance;
                }
           }
           优点：可以实现懒加载方式,线程安全
           缺点：每次获取实例都要进行线程同步，效率地下。实际开发中不推荐使用该方法
       5.双重检查（推荐使用）
          public class A{
            //volatitle可以使修改立即生效到内存，是一个轻量级的同步锁
            private static volatitle A instance;
            private A(){}
            //双重检查
             public static A getInstance(){
                if(instance == null){
                    syncronized(A.class){
                        if(instance == null){
                            instance = new A();
                         }
                    }
                }
                return instance;
                }
           }
        6.静态内部类（当类加载的时候，静态内部类不会被加载，当使用静态内部类时会进行线程安全的加载,推荐使用）
          public class A{
            private static A instance;
            private A(){}
            private static class AInstance{
              private static final A INSTANCE = new A();
            }
             public static A getInstance(){
                return AInstance.INSTANCE;
             }
           }
        7.枚举（推荐使用）
          enum A{
              INSTANCE;
              public void sayOk(){
                system.out.println("ok...");
              }
          }
          优点：借助JDK1.5添加的枚举来实现单例。不仅能避免线程同步问题，而且还能防止反序列化重新创建对象。
          
  简单工厂模式(静态工厂模式)
  工厂方法模式
      定义了一个创建对象的抽象方法，由子类决定要实例化的的类。工厂方法模式将对象实例化推迟到子类。即将项目的实例化工程抽象成抽象方法，在不同的子类中具体实现。
  抽象工厂模式
      定义了一个interface用于创建相关或有依赖关系的对象簇，而无需指明具体的类。
  原型模式
      用原型实例指定创建种类，并且通过拷贝这些原型，创建新的对象。原型模式是一种创建型设计模式，允许一个对象再创建另一个可定制的对象，无需知道创建细节
      工作原理：通过一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝他们自己来实现创建，即 对象.clone()
      深拷贝：1.重写clone方法实现深拷贝  2.通过对象序列化实现深拷贝（推荐）
      序列化实现demo：
        public class A implement CloneAble,serializable{
          private int a;
          private String b;
          private C c;
          
          //浅拷贝
          @override
          public Object clone{
            A aa= null;
            try{
              aa = (A)super.clone();
            }catch(Exception e){
              e.printStackTrace();
            }
          }
          
          //深拷贝
          public A deepCopy(){
            ByteArrayOutputStream bos = null;
            ObjectOutputStream oos = null;
            ByteArrayInputStream bis = null;
            ObjectInputStream ois = null;
            try {
              //序列化
              bos = new ByteArrayOutputStream();
              oos = new ObjectOutputStream(bos);
              //将当前对象以对象流的方式输出
              oos.writeObject(this);
              //反序列化
              bis = new ByteArrayInputStream(bos.toByteArray());
              ois = new ObjectInputStream(bis);
              B copyObj = (B)ois.readObject();
              return copyObj;
            } catch(Exception e){
              e.printStackTrace();
              return null;
            }finally{
              try{
              bos.close();
              oos.close();
              bis.close();
              ois.close();
              }catch(Exception e2){
              e2.printStackTrace();
              }
            }
          }
        }
  建造者模式（build pattern）
      又名生成器模式,是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。建造者模式是一步一步创建一个复杂的对象，他允许用户只通过指定复杂对象的类型和内容就可以构建他们，用户不需要知道内部的具体构建细节。
      建造者模式中的四个角色：
          1.product(产品角色):一个具体的产品对象。
          2.builder(抽象建造者):创建一个product对象的各个部件指定的接口/抽象类。
          3.concreteBuilder(具体建造者):实现接口，构建和装配各个部件。
          4.director(指挥者):构建一个使用builder接口的对象。他主要是用于创建一个复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程。适用范围是产品之间差异性不大
  适配器模式(Adapter Pattern)
      将某个类的接口转换成客户期望的另一个接口表示，主要目的是兼容性，让原本接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器(Wrapper),适配器模式属于结构模型模式，主要分为三类：类适配器模式、对象适配器模式、接口适配器模式
  桥接模式（bridge）-结构型设计模式
      将实现与接口抽象放在两个不同的类层次中，使两个层次可独立给改变。桥接模式是基于类的最小实际原则，通过使用封装、聚合及继承等行为让不同的类承担不同的职责。它的主要特点是把抽象与行为实现分离开来，从而可以保持各个部分的独立性以及应对他们的功能扩展
    装饰者设计模式（Composite Pattern）--结构型模式
        动态的将信功能附加到对象上。在对象功能扩展方面，它继承更有弹性，装饰者模式也体现了开闭原则（ocp）。 
    组合模式
        组合模式又称部分整体模式，它创建了对象组的树形结构，将对象组合成树状结构以表示“整体-部分”的层次关系。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。该模式使得用户对单个对象和组合对象的访问具有一致性，即：组合能让客户以一致的方式处理个别对象以及组合对象
    外观模式（Facade）--结构性设计模式
        外观模式也叫过程模式，该模式为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。即通过定义一个一致的接口，可以屏蔽内部子系统的细节，使得调用端只需要跟这个接口发生调用，而无需关心这个子系统内部细节。
    享元模式（flyweight pattern）
        享元模式也叫蝇量模式：运用共享技术有效地支持大量细粒度的对象，常用于系统底层开发，解决系统的性能问题。想数据库连接池，里面都是创建好的连接对象，在这些连接对象中我们需要的则直接拿来用，避免重新创建，如果没有我们需要的，则创建一个。享元模式能够解决重复u第项的内存浪费问题，当系统中有大量相似对象，需要缓冲池时。不需要总是创建新对象，可以从缓冲池里拿。这样可以降低系统内存，同时提高效率。香园模式经典的应用场景就时池技术了，String常量池、数据库连接池、缓冲池等等都是享元模式的应用，享元模式是池技术的重要实现方式 
    代理模式（Proxy）
        为一个对象提供一个替身，可以控制对这个对象的访问。即通过代理对象访问目标对象。这样做的好处是：可以在目标对象实现的基础上，增强额外的功能操作，即扩展目标对象的功能。被代理的对象可以是远程对象、创建开销大的对象或需要安全控制的对象。代理模式有不同的形式，主要有三种 静态对象、动态代理（JDK代理）和Cglib代理（可以在内存中动态的创建对象，而不需要实现接口，他是属于动态代理的范畴）。
        静态代理模式，需要定义接口或者父类，被代理对象（即目标对象）与代理对象一起实现相同的接口或者是集成相同的父类。
            例如:
                定义一个接口ITeacherDao
                目标对象TeacherDao实现接口ITeacherDao
                使用静态代理方式，就需要在代理对象TeacherDaoProxy中也实现ITeacherDao
                调用的时候通过调用代理对象的方法来调用目标对象
                特别提醒：代理对象与目标对象要实现相同的接口，然后通过调用相同的方法调用目标对象的方法。
        动态代理模式，代理对象，不需要实现接口，但是目标对象要实现接口，否则不能用动态代理。代理对象的生成，是利用JDK的API，动态的在内存
中构建代理对象。
            jdk中生成代理对象的api：
                代理类所在包：java.lang.reflect.Proxy
                JDK实现代理只需要使用newProxyInstance方法，但是该方法需要接受三个参数，完整的是：
                    static Object newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHandler h)
         Cglib代理模式，静态代理何JDK代理模式都要求目标对象实现一个接口，但是有的时候目标对象只是一个单独的对象，并没有任何的接口，这个时候可以使用目标对象子类来实现代理-这就是Cglib代理。Cglib代理也叫子类代理，它是在内存中构建一个子类对象从而实现对目标对象功能扩展，有些书也将Cglib代理归属到动态代理。Cglib是一个强大的高性能的代码生成包，它可以在运行期扩展java类与实现java接口，它广泛的被许多aop框架使用，例如srping aop，实现方法拦截。在aop变成中如何选择代理模式：1.目标对象需要实现接口，用JDK代理 2.目标对象不需要实现接口，用Cglib代理。Cglib包的底层时通过使用字节码处理框架ASM来转换字节码并生成新的类。注意Cglib代理不能代理final修饰的类，目标对象的方法如果为final/static，那么就不会被拦截，即不会执行目标对象的额外业务方法
    模板方法模式（Template Method Pattern）--行为型模式
        模板方法模式又叫模板模式(Template Pattern)，在一个抽象类公开定义了执行它的方法的模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。简单的说，模板方法模式定义一个操作中的算法股价，而将一些步骤延迟到子类中，使得子类可以不改变一个算法结构，就可以重定义该算法的某些特定步骤。
        钩子方法
            在模板方法模式的父类中，我们可以定义一个方法，它默认不做任何事，子类可以视情况要不要覆盖它，该方法成为“钩子”。比如都将制作的要纯豆浆就不用覆盖。
    命令模式（Command Pattern）
        在软件设计中，我们经常需要知道向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个，我们只需要在程序运行时指定具体的请求接收者即可，此时，可以使用命令模式来进行设计。命令模式将发起的对象与执行请求的对象解耦。发起请求的对象是调用者，调用者只要调用命令对象的execute()方法就可以让接收者工作，而不必知道具体的接收者对象是谁、是如何实现的，命令对象会负责让接收者执行请求的动作，也就是说：“请求发起者”和“请求执行者”之间的解耦是通过命令对象实现的，命令对象起到了纽带桥梁的作用。容易设计一个命令队列。只要把命令对象放到队列，就可以多线程的执行命令。容易实现对请求的撤销和重做。命令模式不足：可能导致某些系统有过多的具体命令类，增加了系统的复杂度，这点在使用的时候要注意。空命令也是一种设计模式，它为我们省去了判断空的操作。在上面的实例中，如果没有用空命令，我们每按下一个按键都要判空，这给我们编码带来一定的麻烦。命令模式经典的应用场景：界面的一个阿牛都是一条命令、模拟CMD(DOS命令)订单的撤销/恢复、触发-反馈机制。
    访问者模式（Visitor Pattern）
        封装一些作用于某种数据结构的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。主要将数据结构与数据操作分离，解决数据结构和操作耦合性问题。访问者模式的基本工作原理是：在被访问的类里面加一个对外提供接待访问者的接口。访问者模式主要应用场景是：需要对一个对象结构中的对象进行很多不同操作（这些操作彼此没有关联），同时需要避免让这些操作“污染”这些对象的类，可以选用访问者模式解决。有点：访问者模式符合单一职责原则、让程序具有优秀的扩展性、灵活性非常高，访问者模式可以对功能进行统一，可以做报表、UI、拦截器与过滤器，适用于数据结构相对稳定的系统。缺点：具体元素对访问者公布细节，也就是说访问者关注了其他类的内部细节，这是迪米特法则所不建议的，这样造成了具体元素变更比较困难，违背了依赖倒转原则。访问者依赖的是具体元素，而不是抽象元素。因此，如果一个系统有比较稳定的数据结构，又有经常变化的功能需求，那么访问者模式就是比较适合的。
    迭代器模式（Iterator Pattern）--行为模式
       如果我们的集合元素是用不同的方式实现的，有数组，还有java的集合类或者还有其他方式，当客户端要遍历这些集合元素的时候就要使用多种便利方式，而且还会暴露元素的内部结构，可以考虑使用迭代器模式解决。迭代器模式，提供一种遍历集合元素的统一接口，用一致的方法遍历集合元素，不需要知道集合对象的底层表示，即：不暴露其内部的结构。优点：提供一个统一的方法遍历对象，客户不用再考虑聚合的类型，使用一种方法就可以遍历对象了。隐藏了聚合的内部结构，客户端要遍历聚合的时候只能取到迭代器，而不会知道聚合的具体组成。提供了一种设计思想，就是一个类应该只有一个引起变化的原因（叫做单一责任原则）。再聚合类中，我们把迭代器分开，就是要把管理对象集合和遍历对象集合的责任分开，这样一来集合改变的话，只影响到聚合对象。而如果遍历方式改变的话，只影响到了迭代器。当要展示一组相似对象，或者遍历一组相同对象时使用，适合使用迭代器模式。缺点：每个聚合对象都要一个迭代器，会生成多个迭代器不好管理类。
    观察者模式（Observer Pattern）--行为模式
        对象之间多对一依赖的一种设计方案，被依赖的对象为Subject，依赖的对象为Observer,Subject通知Observer变化。
    中介者模式（Mediator Pattern）
        中介者模式是用一个中介对象来封装一系列的对象交互。中介者使各个对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。比如MVC模式，C（Controller控制器）是M（Model模型）和V（View视图）的中介者，在前后端交互时起到了中间人的作用。
    备忘录模式(Memento Pattern)--行为模式
        备忘录模式在不破坏封装性的前提下，捕捉一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。可以这样理解备忘录模式：现实生活中的备忘录是用来记录某些要去做的事情，或者是记录已经达成的共同意见的事情，以防忘记了。而在软件层面，备忘录模式有着相同的含义，备忘录对象主要用来记录一个对象的某种状态，或者某些数据，当要做回退时，可以从备忘录对象里获取原来的数据进行恢复操作。适用的场景：1.后悔药 2.打游戏的存档 3.windows里的ctri+z 4.浏览器中的后退 5.数据库的事务管理  如果类的成员变量过多，势必会占用较大资源，而且每一次保存都会消耗一定的内存。为了节省内存，备忘录模式可以和原型模式配合使用。
    解释器模式（Interpreter Pattern）
        在编译原理中，一个算数表达式通过词法分析器形成词法单元，而后这些词法单元再通过语法分析器构建语法分析树，最终形成一颗抽象的语法分析树。这里的词法分析器和语法分析器都可以看作是解释器。解释器模式：是指给定一个语言（表达式），定义它的文法的一种表示，并定义一个解释器，使用该解释器来解释语言中句子（表达式）。应用场景：可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。一些重复出现的问题可以用一种简单的语言来表达。一个简单语法需要解释的场景。这样的例子还有，比如编译器、运算表达式计算、正则表达式、机器人等。





























